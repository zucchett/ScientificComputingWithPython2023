# -*- coding: utf-8 -*-
"""02ex_fundamentals.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aN_2a6X9d4pxW7h36KFp0rq4FxT7TgpM

You can solve these exercises in the room or at home. For this week, and the next 3 weeks, exercises have to be solved by creating a single dedicated `.py` file called `02ex_fundamentals.py`.

You can divide the individual exercises in the source code with appropriate comments (`#`).

The exercises need to run without errors with `python3 02ex_fundamentals.py`.

1\. **Global variables**

Convert the function $f$ into a function that doesn't use global variables and that does not modify the original list
"""

x = 5

def f(alist):
    for i in range(x):
        alist.append(i)
    return alist

alist = [1, 2, 3]
ans = f(alist)
print(ans)
print(alist) # alist has been changed

import copy

def f(alist):
    x = 5
    listCopy = copy.deepcopy(alist)
    for i in range(x):
        listCopy.append(i)
    return listCopy

alist = [1, 2, 3]
ans = f(alist)
print(ans)
print(alist) # alist has not been changed

"""2\. **List comprehension**

Write the following expression using a list comprehension:

`ans = list(map(lambda x: x * x, filter(lambda x: x % 2 == 1, range(10))))`
"""

ans = list(map(lambda x: x * x, filter(lambda x: x % 2 == 1, range(10))))
newlist = [ x * x for x in range(10) if x%2==1]
print(ans)
print(newlist)

"""3\. **Filter list**

Using the `filter()` hof, define a function that takes a list of words and an integer `n` as arguments, and returns a list of words that are shorter than `n`.
"""

def getShorterThanN(alist,n):
  return list(filter(lambda x: len(list(x))< n, alist))
blist = ['elnaz','bmw','benz','mazda','audi']

print('The filtered letters are:',getShorterThanN(blist,5))

"""4\. **Map dictionary**


Consider the following dictionary:

`lang = {"Python" : 3, "Java" : '', "Cplusplus" : 'test', "Php" : 0.7}`

Write a function that takes the above dictionary and uses the `map()` higher order function to return a list that contains the length of the keys of the dictionary.
"""

lang = {"Python" : 3, "Java" : '', "Cplusplus" : 'test', "Php" : 0.7}
result = list(map(lambda k: len(list(k)), lang.keys()))
print(result)

"""5\. **Lambda functions**

Write a Python program that sorts the following list of tuples using a lambda function, according to the alphabetical order of the first element of the tuple:

`language_scores = [('Python', 97), ('Cplusplus', 81), ('Php', 45), ('Java', 32)]`

*Hint*: use the method `sort()` and its argument `key` of the `list` data structure.
"""

def myFunc(e):
  return e[0]

language_scores = [('Python', 97), ('Cplusplus', 81), ('Php', 45), ('Java', 32)]

language_scores.sort(key=myFunc)
print(language_scores)

"""6\. **Nested functions**

Write two functions: one that returns the square of a number, and one that returns its cube.

Then, write a third function that returns the number raised to the 6th power, using only the two previous functions.
"""

def square(x):
  return x*x

def cube(x):
  return x*x*x

def sixth(x):
  return square(cube(x))

print(sixth(2))

"""7\. **Decorators**

Write a decorator named `hello` that makes every wrapped function print “Hello World!” each time the function is called.

The wrapped function should look like:

```python
@hello
def square(x):
    return x*x
```
"""

def hello(func):
    def wrapper(*args):         # *args to take any variables passed from wrapped function
        print("Hello World!")
        return func(*args)
    return wrapper

@hello
def square(x):
  return x*x

print(square(2))

"""8\. **The Fibonacci sequence (part 2)**

Calculate the first 20 numbers of the [Fibonacci sequence](https://en.wikipedia.org/wiki/Fibonacci_number) using a recursive function.
"""

def fibo(n):
   if n <= 1:
       return n
   else:
       return(fibo(n-1) + fibo(n-2))

print([fibo(i) for i in range(20)])

"""9\. **The Fibonacci sequence (part 3)**

Run both the Fibonacci recursive function from the previous exercise, and the Fibonacci function from 01ex that use only `for` and `while` loops.

Measure the execution code of the two functions with `timeit` ([link to the doc](https://docs.python.org/3/library/timeit.html)), for example:

`%timeit loopFibonacci(20)`

`%timeit recursiveFibonacci(20)`

which one is the most efficient implementation? By how much?
"""

# Commented out IPython magic to ensure Python compatibility.
# 01 ex
def ex1_fibo():
  num = 20
  n1, n2 = 0, 1
  fi_list=[n1, n2]

  for i in range(2, num):
      n3 = n1 + n2
      n1 = n2
      n2 = n3
      fi_list.append(n3)

# 02 ex
def ex2_recure_fibo ():
  return [fibo(i) for i in range(20)]

# %timeit ex1_fibo()
# %timeit ex2_recure_fibo()

time_1 = 2.24*pow(10,-6)*100000
time_2 = 6.23*pow(10,-3)*100

print('time fibo loop',time_1)
print('time fibo recur',time_2)

"""#answer:
we see that ricuresive function is around 3 times slower than loop implementation.

10\. **Class definition**

Define a class `polygon`. The constructor has to take a tuple as input that contains the length of each side. The (unordered) input list does not have to have a fixed length, but should contain at least 3 items.

- Create appropriate methods to get and set the length of each side

- Create a method `perimeter()` that returns the perimeter of the polygon

- Create a method `getOrderedSides(increasing = True)` that returns a tuple containing the length of the sides arranged in increasing or decreasing order, depending on the argument of the method

Test the class by creating an instance and calling the `perimeter()` and `getOrderedSides(increasing = True)` methods.
"""

class Polygon:
    sides:list = []

    def __init__(self, sides:tuple):
        if(len(sides)<3):
          raise ValueError('the input of Polygon constructor should have atleast 3 numbers in a tuple.')
        else:
          self.sides = list(sides)

    def getNthSide(self,n):
        if(n > len(self.sides)):
          raise ValueError('the input n is bigger than number of sides')
        return self.sides[n]

    def setNthSide(self,n,x):
        if(n > len(self.sides)):
          raise ValueError('the input n is bigger than number of sides')
        self.sides[n] = x

    def perimeter(self):
        return sum(self.sides)

    def getOrderedSides(self,increasing = True):
        self.sides.sort(reverse = increasing == False)
        return  tuple(self.sides)


poly = Polygon((4,3,6))
poly.setNthSide(0,9)
print(poly.getNthSide(1))
print(poly.perimeter())
print(poly.getOrderedSides())

"""11\. **Class inheritance**

Define a class `rectangle` that inherits from `polygon`. Modify the constructor, if necessary, to make sure that the input data is consistent with the geometrical properties of a rectangle.

- Create a method `area()` that returns the area of the rectangle.

Test the `rectangle` class by creating an instance and passing an appropriate input to the constructor.
"""

class Rectangle(Polygon):
  def __init__(self, sides:tuple):
        if(len(sides)!=2):
          raise ValueError('the input of rectangle constructor must have exactly 2 numbers in a tuple.')
        else:
          self.sides = list(sides)
  def area(self):
    return self.sides[0]*self.sides[1]

rect = Rectangle((2,6))
rect.setNthSide(0,10)
print(rect.getOrderedSides())
print('perimeter: ',rect.perimeter())
print('area: ',rect.area())